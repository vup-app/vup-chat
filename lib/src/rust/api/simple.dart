// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.2.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are not used by any `pub` functions: `MyMemoryKeyStoreError`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `crypto`, `delete`, `eq`, `fmt`, `fmt`, `key_store`, `rand`, `read`, `store`

Future<OpenMlsConfig> openmlsInitConfig(
        {required Map<Uint8List, Uint8List> keystoreValues}) =>
    RustLib.instance.api
        .crateApiSimpleOpenmlsInitConfig(keystoreValues: keystoreValues);

Future<Map<Uint8List, Uint8List>> openmlsKeystoreDump(
        {required OpenMlsConfig config}) =>
    RustLib.instance.api.crateApiSimpleOpenmlsKeystoreDump(config: config);

Future<MlsCredential> openmlsGenerateCredentialWithKey(
        {required List<int> identity, required OpenMlsConfig config}) =>
    RustLib.instance.api.crateApiSimpleOpenmlsGenerateCredentialWithKey(
        identity: identity, config: config);

Future<Uint8List> openmlsSignerGetPublicKey(
        {required SignatureKeyPair signer}) =>
    RustLib.instance.api
        .crateApiSimpleOpenmlsSignerGetPublicKey(signer: signer);

Future<MlsCredential> openmlsRecoverCredentialWithKey(
        {required List<int> identity,
        required List<int> publicKey,
        required OpenMlsConfig config}) =>
    RustLib.instance.api.crateApiSimpleOpenmlsRecoverCredentialWithKey(
        identity: identity, publicKey: publicKey, config: config);

Future<Uint8List> openmlsGenerateKeyPackage(
        {required SignatureKeyPair signer,
        required CredentialWithKey credentialWithKey,
        required OpenMlsConfig config}) =>
    RustLib.instance.api.crateApiSimpleOpenmlsGenerateKeyPackage(
        signer: signer, credentialWithKey: credentialWithKey, config: config);

Future<MlsGroup> openmlsGroupCreate(
        {required SignatureKeyPair signer,
        required CredentialWithKey credentialWithKey,
        required OpenMlsConfig config}) =>
    RustLib.instance.api.crateApiSimpleOpenmlsGroupCreate(
        signer: signer, credentialWithKey: credentialWithKey, config: config);

Future<MLSGroupAddMembersResponse> openmlsGroupAddMember(
        {required MlsGroup group,
        required SignatureKeyPair signer,
        required List<int> keyPackage,
        required OpenMlsConfig config}) =>
    RustLib.instance.api.crateApiSimpleOpenmlsGroupAddMember(
        group: group, signer: signer, keyPackage: keyPackage, config: config);

Future<Uint8List> openmlsGroupCreateMessage(
        {required MlsGroup group,
        required SignatureKeyPair signer,
        required List<int> message,
        required OpenMlsConfig config}) =>
    RustLib.instance.api.crateApiSimpleOpenmlsGroupCreateMessage(
        group: group, signer: signer, message: message, config: config);

Future<MlsGroup> openmlsGroupJoin(
        {required List<int> welcomeIn, required OpenMlsConfig config}) =>
    RustLib.instance.api
        .crateApiSimpleOpenmlsGroupJoin(welcomeIn: welcomeIn, config: config);

Future<ProcessIncomingMessageResponse> openmlsGroupProcessIncomingMessage(
        {required MlsGroup group,
        required List<int> mlsMessageIn,
        required OpenMlsConfig config}) =>
    RustLib.instance.api.crateApiSimpleOpenmlsGroupProcessIncomingMessage(
        group: group, mlsMessageIn: mlsMessageIn, config: config);

Future<Uint8List> openmlsGroupSave(
        {required MlsGroup group, required OpenMlsConfig config}) =>
    RustLib.instance.api
        .crateApiSimpleOpenmlsGroupSave(group: group, config: config);

Future<MlsGroup> openmlsGroupLoad(
        {required List<int> id, required OpenMlsConfig config}) =>
    RustLib.instance.api.crateApiSimpleOpenmlsGroupLoad(id: id, config: config);

Future<List<GroupMember>> openmlsGroupListMembers({required MlsGroup group}) =>
    RustLib.instance.api.crateApiSimpleOpenmlsGroupListMembers(group: group);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < RwLock < HashMap < Vec < u8 > , Vec < u8 > > > >>>
abstract class ArcHashMapVecU8VecU8 implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Ciphersuite>>
abstract class Ciphersuite implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CredentialType>>
abstract class CredentialType implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CredentialWithKey>>
abstract class CredentialWithKey implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MLSCredential>>
abstract class MlsCredential implements RustOpaqueInterface {
  CredentialWithKey get credentialWithKey;

  SignatureKeyPair get signer;

  set credentialWithKey(CredentialWithKey credentialWithKey);

  set signer(SignatureKeyPair signer);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MlsGroupConfig>>
abstract class MlsGroupConfig implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MyMemoryKeyStore>>
abstract class MyMemoryKeyStore implements RustOpaqueInterface {
  ArcHashMapVecU8VecU8 get values;

  set values(ArcHashMapVecU8VecU8 values);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MyOpenMlsRustCrypto>>
abstract class MyOpenMlsRustCrypto implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OpenMLSConfig>>
abstract class OpenMlsConfig implements RustOpaqueInterface {
  MyOpenMlsRustCrypto get backend;

  Ciphersuite get ciphersuite;

  CredentialType get credentialType;

  MlsGroupConfig get mlsGroupConfig;

  SignatureScheme get signatureAlgorithm;

  set backend(MyOpenMlsRustCrypto backend);

  set ciphersuite(Ciphersuite ciphersuite);

  set credentialType(CredentialType credentialType);

  set mlsGroupConfig(MlsGroupConfig mlsGroupConfig);

  set signatureAlgorithm(SignatureScheme signatureAlgorithm);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RwLock < MlsGroup >>>
abstract class MlsGroup implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SignatureKeyPair>>
abstract class SignatureKeyPair implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SignatureScheme>>
abstract class SignatureScheme implements RustOpaqueInterface {}

class GroupMember {
  final Uint8List identity;
  final int index;
  final Uint8List signatureKey;

  const GroupMember({
    required this.identity,
    required this.index,
    required this.signatureKey,
  });

  @override
  int get hashCode =>
      identity.hashCode ^ index.hashCode ^ signatureKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupMember &&
          runtimeType == other.runtimeType &&
          identity == other.identity &&
          index == other.index &&
          signatureKey == other.signatureKey;
}

class MLSGroupAddMembersResponse {
  final Uint8List mlsMessageOut;
  final Uint8List welcomeOut;

  const MLSGroupAddMembersResponse({
    required this.mlsMessageOut,
    required this.welcomeOut,
  });

  @override
  int get hashCode => mlsMessageOut.hashCode ^ welcomeOut.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MLSGroupAddMembersResponse &&
          runtimeType == other.runtimeType &&
          mlsMessageOut == other.mlsMessageOut &&
          welcomeOut == other.welcomeOut;
}

class ProcessIncomingMessageResponse {
  final bool isApplicationMessage;
  final Uint8List applicationMessage;
  final Uint8List identity;
  final Uint8List sender;
  final BigInt epoch;

  const ProcessIncomingMessageResponse({
    required this.isApplicationMessage,
    required this.applicationMessage,
    required this.identity,
    required this.sender,
    required this.epoch,
  });

  @override
  int get hashCode =>
      isApplicationMessage.hashCode ^
      applicationMessage.hashCode ^
      identity.hashCode ^
      sender.hashCode ^
      epoch.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProcessIncomingMessageResponse &&
          runtimeType == other.runtimeType &&
          isApplicationMessage == other.isApplicationMessage &&
          applicationMessage == other.applicationMessage &&
          identity == other.identity &&
          sender == other.sender &&
          epoch == other.epoch;
}
